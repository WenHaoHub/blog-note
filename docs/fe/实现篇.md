# Array

## forEach

### 实现

```js {12,15}
Array.prototype.myForEach = function (callback, thisArg) {
  // this 指向当前数组
  const array = this
  console.log('>>>this', this) //[1, 2, 3, 4]
  // 检查回调函数是不是函数
  if (typeof callback !== 'function') {
    throw new TypeError(callback + ' is not a function')
  }
  // 遍历数组的每个元素
  for (let i = 0; i < array.length; i++) {
    // 回调函数参数：当前元素，当前索引，原数组
    // 如果提供了 thisArg 参数，则将其作为回调函数的 this 值，否则默认为 undefined
    callback.call(thisArg, array[i], i, array)
  }
}

let a = [1, 2, 3, 4]
a.myForEach((item, index) => {
  console.log(item, index)
})
```

### 注意事项

为什么 forEach 中不能 return？

1. 这个回调函数由你提供，并在 forEach 的每次迭代过程中被调用。
2. 在 forEach 的回调函数中，使用 return 确实会退出当前正在执行的回调函数，但它并不能退出 forEach 循环本身。

## call

### 实现

基本思路是将目标函数设为某个对象的属性，然后调用这个属性（即目前是函数的方法），这样函数内的 this 就绑定到了这个对象上。完成调用后，再删除这个临时属性。

> 相当与将之前的 window 调用函数 变成了对象调用 `foo.call(obj) === obj.foo()`

```js {7,8,14}
Function.prototype.myCall = function (context) {
  // 如果没有传入上下文对象，则默认绑定到全局对象（浏览器中为 window）
  context = context || globalThis

  // 将当前被调用的方法（this，因为myCall将会作为函数方法被调用）添加到上下文对象的一个属性上
  const fn = Symbol('fn') // 使用 Symbol 防止原有属性的覆盖
  //foo.call({}) foo调用了call 执行到这里的时候this是foo
  context[fn] = this // this 指向调用 myCall 的函数对象

  // 从 Arguments 对象中取出传入的参数数组，从第二个参数开始，因为第一个参数是绑定的上下文
  const args = Array.from(arguments).slice(1)

  // 调用函数，并将结果存储起来
  const result = context[fn](...args)

  // 删除临时属性
  delete context[fn]

  // 返回函数执行的结果
  return result
}

// 然后就可以这样使用自定义的 myCall 方法了：
function showName(label) {
  console.log(label + ': ' + this.name)
}

const person = showName.myCall({ name: 'Alice' }, 'Name') // 输出: Name: Alice
```

## new

### 实现

1. 创建一个空对象。
2. 将这个空对象的原型指向构造函数的原型属性。
3. 将这个空对象赋值给函数内部的 `this` 关键字。
4. 执行构造函数中的代码（为这个新对象添加属性）。
5. 如果构造函数返回非空对象，则返回该对象；否则，返回步骤 1 创建的对象。

```javascript {6,10}
function myNew(Constr, ...args) {
  // 步骤1: 创建一个空对象
  const obj = {}

  // 步骤2: 将空对象的原型指向构造函数的 prototype
  Object.setPrototypeOf(obj, Constr.prototype)
  // obj.__proto__ = Constr.prototype; 这种方式也行

  // 步骤3&4: 将 obj 作为 this 传给构造函数执行，接收构造函数返回的对象
  const result = Constr.apply(obj, args) //undefined
  //执行了这一步 将obj作为this 给obj调用了Constr方法 给调用者的 this设定了值
  // obj == Person={
  //     age: 30,
  //     name: "Alice",
  //     [[Prototype]]: Object
  // }
  // 步骤5: 判断构造函数返回值类型，如果是对象或函数，则返回该值；否则返回步骤1创建的对象
  return (typeof result === 'object' && result !== null) || typeof result === 'function'
    ? result
    : obj
}

// 测试 myNew 函数
function Person(name, age) {
  this.name = name
  this.age = age
}

Person.prototype.sayName = function () {
  console.log(`My name is ${this.name}`)
}

// 用 myNew 创建 Person 实例
const person = myNew(Person, 'Alice', 30)
console.log(person) // Person { name: 'Alice', age: 30 }
person.sayName() // 输出: My name is Alice
```

第 10 行参考代码

```js
let obj = {
  foo() {
    this.a = 1
  },
}
obj.foo()
obj == { a: 1, foo: foo() }
```
