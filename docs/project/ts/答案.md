# html+css

13631717911 WNCD202004054

![html+css](C:\Users\Administrator\Desktop\react资料\蜗牛学院面试题\html+css.png)

1. 标准盒模型和怪异盒模型的区别

   - 标准：总 width（height）=设置的 content 的宽高+padding+border+margin ， 它的内容区是不包含填充区和边框的
   - 怪异： 总 width（height）=设置的 width（height）+外边距 margin ， 它的内容区是包含填充区和边框的

2. sessionStorage 和 localStorage 的区别

   - localStorage 和 sessionStorage 一样都是用来存储客户端临时信息的对象。
   - 他们均只能存储字符串类型的对象，用 pares justify 转换
   - localStorage 生命周期是永久，除非用户手动清除 localStorage 信息。
   - sessionStorage 生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过 sessionStorage 存储的数据也就被清空了
   - 不同浏览器无法共享 localStorage 或 sessionStorage 中的信息。相同浏览器的不同页面间可以共享

3. 页面导入样式是使用 link 和@import 有什么区别

   - link 属于 HTML 标签，除了加载 css 外，还能用于定义 RSS，定义 rel 连接属性等作用，而@import 是 css 提供的一种方式，只能用于加载 css
   - link 加载内容是与页面同时加载的，而@import 需要页面完全加载完毕之后再加载
   - @import 是 css2.1 提出的，只有在 IE5 以上才能被识别，而 link 是 XHTML 标签，无兼容问题
   - link 支持使用 JavaScript 控制 Dom 去改变样式，而@import 不支持
   - link 方式引入的样式的权重高于@import

4. websocket 和 http 有什么区别

   - WebSocket 本质上是一种计算机网络应用层的协议，用来弥补 HTTP 协议在持久通信能力上的不足
   - WebSocket 是以类似 Socket 的 TCP 长连接通讯模式，是全双工方式， 和 HTTP 一样都是基于 TCP 协议。

5. visibility:hidden 和 display:none 有什么区别

   - visibility: hidden 也可以隐藏这个元素，但是隐藏元素仍需占用与未隐藏时一样的空间，也就是说虽然元素不可见了，但是仍然会影响页面布局。
   - display: none，那么该元素以及它的所有后代元素都会隐藏，隐藏后的元素无法点击，无法使用屏幕阅读器等辅助设备访问，占据的空间消失。

6. 如何让一个盒子在水平方向和垂直方向都居中

   - 弹性盒子（不考虑兼容性）
   - 定位（已知子宽高）left: 50%，top: 50%， *margin-left: -50px，*margin-top: -50px
   - 定位（未知子宽高）left: 0，right: 0，top: 0，bottom: 0，margin: auto
   - 定位加 transform-translate 平移 left: 50%， top: 50%，transform: translate(-50%,-50%子元素负一半)

7. less 或者 sass 相比于 css 有什么优势?

   - 混入(Mixins)——class 中的 class；
   - 参数混入——可以传递参数的 class，就像函数一样；
   - 嵌套规则——Class 中嵌套 class，从而减少重复的代码
   - 运算——CSS 中用上数学；
   - 颜色功能——可以编辑颜色；

8. 如何做响应式布局或者如何适配

   - 响应式布局（媒体查询@ media ）
   - 流式布局
   - **em**相对于父元素的字体大小的单位，如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸
   - **rem**（font size of the root element）是指相对于根元素的字体大小的单位

9. css sprite(雪碧图或者精灵图)有什么优缺点?

   - 减少 HTTP 请求数，极大地提高页面加载速度，增加图片信息重复度，提高压缩比，减少图片大小
     更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现
   - 图片合并麻烦，维护麻烦，修改一个图片可能需要从新布局整个图片，样式

10. 你知道哪些 css3 新特性和 h5 新特性

    - 颜色、文字阴影（text-shadow、）、边框： 圆角、框阴影：盒子模型：box-sizing、.背景、渐变：linear-gradient、radial-gradient、 过渡：transition，可实现动画、 媒体查询，多栏布局、2D 转换：transform：translate(x，y) rotate(x，y) skew(x，y) scale(x，y)、3D 转换
    - 拖拽释放(Drag and drop) API、语义化标签（header,nav,footer,aside,article,section）(audio,video)、画布(Canvas) API、地理(Geolocation) API、本地离线存储、表单控件，calendar、date、time、email、url、search 、新的技术 webworker, websocket, Geolocation

11. doctype

    声明叫做文件类型定义，告诉浏览器该文件的类型。让浏览器解析器知道应该用哪个规范来解析文档

12.

# js

![js](C:\Users\Administrator\Desktop\react资料\蜗牛学院面试题\js.png)

1. . js 数据类型有哪些?有什么区别
   .
   .

   .
   .
   .
   .
   .

   0.

   分两大类

   - 基本数据型

     放在**堆**里 string number boolean null undefined Symbol （ es6 对象永不相等 ）

   - 引用类型

     1. 堆比栈大，栈比堆速度快
     2. **栈**放地址 **堆**放本体
     3. 堆内存是无序存储，可以根据引用直接获
     4. object(function、Data、Array)

2. 谈一下你对作用域的理解

   - 变量和函数的（标识符）的作用范围，
   - 全局作用域 局部作用域（函数作用） 块级作用域（es6 let const）
   - 作用域链：作用域查找的过程

3. 谈一下你对原型的理解

   - 每个函数都有一个 prototye（原型）属性，这个属性是个对象
   - 构造函数 `prototype` 对象默认有一个 `constructor` 属性, 这个 `constructor`属性指向 `prototype` 属性所在的构造函数(User)
   - 每个对象都有个隐式原型\_Proto\_\_\_，实例上的隐式原型指向构造函数的显示原型
   - 通过 `new` 构造函数的到的实例对象都有一个 `__proto__` 属性, 这个属性是一个对象, 实例对象 proto 属性指向构造函数的 `prototype`属性，\__proto_=prototype
   - 显示原型 prototypr 隐式原型\__proto_
   - Object.prototype 是原型链的尽头

   ```
   全局
   局部（函数作用）
   块级let const
   f
   object.prototype._proto__=== null
   */
   function test()i
   ll this.name ="张三';
   }
   Test.prototype.name = '李四';
   console.dir(Test.prototype.constructor === Test)
   const test = new Test();
   console.log(object.prototype._proto__ === null)
   console.log(test.name);

   ```

4. 原型链

   1. 一个对象调用属性时, 首先自身查找对应的属性
   2. 如果自身有对应的属性, 则返回该该属性对应的值
   3. 如果自身没有对应得属性, 则向上级原型对象中查找,
   4. 如果原型对象中有, 则返回对应属性的值
   5. 如果没有再依次向上级查找, 找到就立即返回对应属性的值
   6. 如果到原型链的末端都没有找到就返回 `undefined`

5. 什么是闭包

   是一个函数

   - 特点——能够访问其他作用域的函数或变量
   - 作用——延长变量的生命周期，
   - 缺点——可能导致内存溢出

   ![1598926755703](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1598926755703.png)

   里面函数是闭包

6. 如何修改函数的 this 指向，这些方法之间有什么区别

   - bind 返回一个新的函数
   - call
   - appiy

   ```js
   const obj = i
       a : 123,
       test:test,
       }
   function test() i
       const name =‘张三"
       console.log(this)
       return function () i
       console.log(name);

   test.call(obj,1,2,3);
   test.apply(obj,[1,2,3]);

   ```

7. 事件委托或者事件代理的原理是什么?

8. 事件冒泡和事件捕获的区别是什么?

   - 冒泡： 从实际操作的元素（事件）向上级父元素一级一级执行下去，直到达到<html>
   - 捕获： 浏览器检查元素的最外层祖先<html>，是否在捕获阶段中注册了一个 onclick 事件处理程序，如果是，则运行它。
     然后，它移动到<html>中的下一个元素(点击的元素的父元素)，并执行相同的操作，然后是下一个元素(点击的元素的父元素)，依此类推，直到到达实际点击的元素。
   - 区别 ：执行顺序的不同

9. 你知道的 es6 新特性有哪些?

   - let const
   - 箭头函数
   - 解构赋值
   - 扩展运算符
   - 模板字符串
   - set map
   - 数组相关 map（） renduce filter forEach
   - promise
   - asyne await

10. js 异步编程方式有几种

- 回调 （回调地域）
- promise （回调地域）
- async await

11. promise 有几种状态

    - 等待 pending
    - 已完成 fulfilled（调用 resolve=>pengding=>fulfilled）
    - 以拒绝 rejected（调用 reject=>pending=>rejected）

    ```js
    function test(){
        lreturn new Promise((resolve,reject)=>i
            //resolve(123)  成功执行 res
            //reject(321)   失败执行 err
            }
        }
    test()
        .then( (res)=>{  //成功执行
            console.log( 'res ' ,res);
          })
        .catch((err)=>i  //失败执行
            console.log( 'err' ,err)
           })

    ```

    ![js2](C:\Users\Administrator\Desktop\react资料\蜗牛学院面试题\js2.png)

12. 浅拷贝

    - 展开运算符
    - const newobj=Object.assign({},obj)

    深拷贝

    - const newobj=JSON.parse(JSON.stringify（obj) 注意 不能拷贝函数

13. 区别

    - px 它的含义是像素的意思，在指定字体大小和元素的宽高的时候使用。像素是相对于显示器屏幕分辨率而言的
    - em： em 是一个相对长度的单位，是相对于当前对象内文本的字体尺寸。如过我们未设置当前文本的字体尺寸，那么 em 就会相对于浏览器的默认字体尺寸
    - rem

14. break:跳过（终止）整个循环 continue：跳过当次循环，执行下一次循环

15. 事件稳妥

    - DOM.addeventListener（‘click’，function1）

      DOM.addeventListener（‘click’，function2）

    - onClick=(fin1;fun2)

16. 执行栈 >>>任务队列 >>>其他线程 >>>任务队列（回调）>>> 执行栈

17. 防抖节流

    - 防抖 指触发事件后在 n 秒内函数只执行一次，若在 n 秒内再次触发则重新计算 （频繁执行性能开销）

      防抖用于减少函数调用次数，对于频繁的调用，只执行这些调用的最后一次。

    - 节流 连续发生的事件在 n 秒内只执行一次函数

      节流用于减少函数请求次数，与防抖不同，节流是在一段时间执行一次

    ```js
    <body>
        <div id="app">
           <div id="test">点我</div>
           <button id="btn">点我修改文本</button>
        </div>
        <script>
            window.addEventListener( ' resize', debunce(getwidth,1080))
            function debunce(func, wait) i
                let timer = null;
                return function ( i
                if(timer)clearInterval(timer);
                  timer = :setTimeout(function- () {
                ..- func();
                },wait);

    	function throllte(func,wait)i
            let prev = +new Date();1l上一次执行的时间戳
            const _this = this;
            return function()i
            const cur = +new Date();l/当前函数执行的时间戳
            if(cur - prev >=wait{
            func.call(this);
            prev = cur;
            )


            function getwidth()
              const width = document.getElementById( 'test' ).offsetwidth;
              console.log(width)
        </script>
    </body>

    ```

18. 柯理化（常用于游戏开发）

    是把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术

    优点

    - 参数复用，由于参数可以分开传入，我们可以复用传入参数后的函数
    - 延迟执行，就跟 `bind` 一样可以接收参数并返回函数的引用，而没有调用

    ```
    function sum(a)i
         return function(b){
             return function(c){
               return a +b;
            }
        }
    }
    const res = sum(1)(2)(3);
    ```

19. fg

20. - http:明文传输
    - https：加密传输，安全性更高，传输内容多性能降低，收费

21. 实时刷新数据的方法

    - 轮询（间隔多少时间向后台请求数据）
    - websocket 前后端相互通讯协议 实时

22. 宏任务，微任务

    - 宏任务 同步宏任务，异步宏任务（setTimeout setInterval）
    - 微任务 只有异步有微任务（Promise、，Object.observe(监听对象属性变化) 、MuTationObserve(监听 Dom 节点变化)）

    - 同步宏任务----》异步微任务----》异步宏任务

    - 任务队列 先取微任务队列回调，在取宏任务队列的回调

      ```js
      let a = 10
      console.log('1', a) //10
      setTimeout(() => {
        //异步宏任务
        a += 20
      }, 1000)
      console.log('2', a) //10
      setTimeout(() => {
        //异步宏任务
        console.log('3', a) //30 10
      }, 100)
      console.log('4', a) //10
      new Promise((resolve, reject) => {
        console.log('5', a) //10
        resolve()
      }).then(() => {
        //异步微任务
        console.log('6', a) //10
      })
      console.log('7', a) //10
      // 1-10 2-10 4-10 5-10 7-10 6-10 3-10(有时间差，都为1000则是30)
      ```

23. var 的变量和 function 的函数名重名时的执行结果

    变量提升时 function 权重高，真正执行时 var 权重高

    ```js
    console.log(a) //f a(){}
    var a = 10
    function a() {}
    console.log(a) //10
    ```

24.

# Vue

1. vue 组件中 watch 和 computed 的区别

   ```js
    watch: {
         "name": function(newVal, oldVal) {
           //.....
         },
         "$route.path": function() { }
       }
   computed:{
         sec: {
           get: function(){ return this.thir}, //只要function中的数据（这里是thir）发生变化，就会触发函数
           set: function(val){ return 1}
         }
   ```

   - 使用`watch`可以监听当前`data`中的数据（变化），，值为一个函数。当`name`的值发生改变时，则立即执行对应的函数
   - watch 不仅可以监听 data 中的数据，还可以监听路由的变化。
   - 只要当函数定义的内部数据发生变化，即会触发函数。函数返回的值便是`sec`的新值当`sec`属性发生改变，触发`set`函数，若 sec 中只有一个函数，则会默认定义了`get`set`函数中可以传一个参数，为当前数据新的值

   区别:

   1. watch 是一对多 可做一些性能消耗较大的 发送请求等
   2. computed 是多对一 最终只返回一个值 母体数据衍生出来的 母体数据有多个

2. vue 常用的生命周期钩子函数有 哪些?分别有什么作用?

   - created 数据初始化完毕
   - mounted Dom 加载完毕
   - updated
   - beforeDestory

3. vue 如何实现组件通信(组件传值) ?父好兄弟复杂组件关系

   - 子父 this.$emit('dd',值)

   - 兄弟 状态提升，将数据提升到父级统一管理

     ​ 事件总线，利用事件的监听和触发来实现组件之间的通信
     ​ vue.prototype.$bus = new vue(); 触发

     ​ this.$bus.$on( "test" ,function(params)i}) 监听

   -

4. vue 如何提取组件的公共逻辑

   - 状态机 vuex
   - mixins

5. vue 项目如何做路由拦截?

   路由守卫

6. 守卫

   - 全局守卫。router.beforeEach((to, from, next) => { }
   - 路由独享守卫。beforeEnter
   - 组件内守卫 beforeRouteLeave（离开时）

7. vue 的响应式原理 Object.defineProperty

   Object.defineProperty(obj,'obj.xx',{

   ​ get function(){}

   ​ set function(){}

   })

8. v-if 和 v-show 的区别

   操作节点 性能低 操作 css 性能高

9. keep-alive 组件有什么作用

   - 包裹组件 缓存组件 不会被卸载
   - acticated deactivate 激活/未激活

10. this $nextTick 有什么作用

    - vue 响应式的改变一个值以后，此时的 dom 并不会立即更新，如果需要在数据改变以后立即通过 dom 做一些操作，可以使用$nextTick 获得更新后的 dom。
    - 修改数据之后使用 nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 nextTick，则可以在回调中获取更新后的 DOM
    - 处理数据动态变化后，DOM 还未及时更新的问题，用 nextTick 就可以获取数据更新后最新 DOM 的变化

11. vue 如何做路由懒加载

    加载当前页面所需要的资源或 js 通过 component 引入组件

12. this.$set 有什么作用

    - vue 组件初始化的过程中，会调用 getter 和 setter 方法，所以该属性必须是存在在 data 中，视图层才会响应该数据的变化
    - 给 data 添加动态属性 ，添加的可被监听属性
    - this.$set(‘对象名’,要修改的属性名,属性值),这样新添加的属性值会被 Vue 监听到并且同步渲染到页面上

13. 提取公共逻辑 vuex mixins 混入

14. VUEX 的核心概念

    State, Getters, Mutation, Action, Module

15. MVVM 理解

    - View 是用户在屏幕上看到的结构、布局和外观，也称 UI。
    - ViewModel 是一个绑定器，能和 View 层和 Model 层进行通信。
    - Model 是数据和逻辑。
    - View 不能和 Model 直接通信，它们只能通过 ViewModel 通信。Model 和 ViewModel 之间的交互是双向的，ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。
    - 严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 在组件提供了 `$refs` 这个属性，让 Model 可以直接操作 View，违反了这一规定。

16. data 为什么是函数

    - 组件可能被用来创建多个实例 （ 指的是组件复用的情况 ） ，如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。 （ 使用函数返回一个对象，由于是不同引用 ）

17. vue 指令

    - v-if
    - v-for
    - v-show
    - v-html 会将变量里的 html 标签解析出来，而{{}}或 v-text 直接解析为字符串
    - v-model 双向绑定
    - v-on @--绑定事件监听器
    - v-bind :--绑定 DOM 属性

18. （混入）mixin 的作用

    - `Vue.mixin()` 可以把你创建的自定义方法混入**所有的** `Vue` 实例。 实现**一次代码，无限复用**

    - 混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。

    - 就是有很多组件需要同一个方法。同一个变量。做同样的事。这个时候就用到这个混入的功能。混入之后变量组件内可用，方法也可用，写在周期函数的代码也会执行

    - 几个组件内都调用了同一个函数同一个变量，执行同一个操作。此时要是使用这个。要和 vuex 区分开，vuex 管理数据统一，混入是变量统一，但是每个变量在组件内是不同的

    - keep-alive 组件记录滚动条位置，回来时跳转到指定滚动位置。

      keep-alive 组件销毁函数

      提示框等等

19.

# react

1. 什么是 JSX?

   仅仅是个语法糖（syntactic sugar），允许开发者在 JavaScript 中书写 HTML 语法。最后，每个 HTML 标签都转化为 JavaScript 代码来运行。

   jsx 语法规则:

   1. 定义虚拟 DOM 时，不要写引号。

   2. 标签中混入 JS 表达式时要用{}

   3. .样式的类名指定不要用 class，要用 className

   4. 内联样式，要用 style=i{key:value}}的形式去写

   5. 只有一个根标签

   6. 标签必须闭合

   7. .标签首字母
      (1).若小写字母开头，则将该标签转为 htm1 中同名元素，若 html 中无该标签对应的同名元素，则

      (2)若大写字母开头，react 就去渲染对应的组件，若组件没有定义，则报错。

2. jsx 的底层原理是什么?

   React.createElement

3. 什么是组件，有什么特点?

4. 组件的数据来源有哪些?他们之间有什么区别?

5. jsx 如何实现列表渲染?

6. jsx 如何实现条件渲染

7. react 组件生命周期分为几大阶段?

- **constructor** 挂载间断 初始化数据
- render _挂载间断 根据数据加载页面_
- componentDidMount _挂载间断 挂载完毕，页面以准备好_
- componentDidUpdate _运行间断 当数据发生改变时执行_
- componentWillUnmount _页面销毁阶段 性能优化_
- 用 useEffect 模拟 体内返回一个函数，函数体内就是销毁 第二个参数为空数组 ue 内就是 Didmount，第二个参数添加依赖 算 upDate

1. 在 componentDidMount 里面可以做什么，在 componentWillUnmount 里面可以做什么?

2. 受控组件和不受控组件

   - 受控：设置 value 值，value 由 state 控制 ， value 值一般在 onChange 事件中通过 setState 进行修改

   - 不受控： 不设置 value 值，通过 ref 获取 dom 节点然后再取 value 值

     ```js
     //受控
     <input type="text" value={this.state.a} onChange={this.get}/>
         state = {a:"你我贷"}
         get = (e) => {this.setState({a: e.target.value;})}
     //不受控
         <input type="text" ref={(node)=> this.a= node} />
         <button onClick={this.get}>click</button>
             get = () => { console.log(this.a.value)}
     ```

3. react 插槽是什么?

4. shouldComponentupdate 有什么作用?

5. react 组件之间如何通信

   - 父子 给子组件定义属性
   - 子父 给子组件定义属性 属性值是一个方法 调用方法传值
   - 兄弟 状态提升 事件总线
   - 复杂

6. 解释一下 redux 核心概念

   redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有

   三个核心方法，action，store，reducer

7. react 常用的生命周期钩子函数有哪些?分别有什么作用

8. react 中 refs 有什么作用?

   - 获取 DOM 节点，获取组件实例

9. .redux 中间件是什么，有什么作用，你常用的中间件有哪些?

   - redux-s

10. .redux 三大原则是什么?

    - 一个项目只有一个 store
    - reducer 必须是纯函数（输入必须对应着唯一的输出）
    - State 是只读的, 想要更改必须经过派发 action

11. .react 中容器组件和展示组件有什么区别?

    - 容器获取管理数据，负责数据
    - 展示被动接受数据渲染数据，负责界面
    - 相互搭配使用 16.8 以前

12. ．函数组件和类组件有什么区别(16.8 以前）?

    - 没有生命周期

13. 你对 react 新特性 hooks 有什么了解吗?

    让行数组件具有类组件特性，生命周期，状态

14. 什么是虚拟 DOM，为什么要使用虚拟 DOM

    - 虚拟 DOM 的概念是由 Facebook 的 React 团队最早提出来的，也是 React 框架的核心概念之一。它的作用是以 js 的形式在内存中描述真实的 DOM 结构，这样当页面内容需要发生变动时，React 可以通过对前后虚拟 DOM 的比对，计算出如何以最小的代价操作真实 DOM。
    - 虚拟 DOM 设计的核心就是用高效的 js 操作，来减少低性能的 DOM 操作，以此来提升网页性能。
    - 当我们使用`jsx`语法定义一个模板时，React 会用它生成一个由 JavaScript 描述的虚拟 DOM 树，并将其保存在 JavaScript 内存中。这个虚拟 DOM 树还保留了我们在模板中定义的数据和视图的绑定关系，这为 React 自动根据数据变化更新视图提供了可能。随后当数据发生变化时，React 重新生成一个虚拟 DOM 树，通过对比两个虚拟 DOM 树的差异，React 就可以知道该如何高效地更新视图。接着它就会调用原生的 DOM 接口，去更新真实 DOM。
    - ![1599583905200](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1599583905200.png)

15. react 列表渲染中的 Key 有什么作用

    - 唯一性
    - 避免一些莫名的 bug，也可以提高代码规范
    - 更加准确:
      添加 key 就不是就地复用了，可以保证自身状态正确。所以会更加准确。让 diff 算法更快更准确
    - 更快速：
      利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快。

16. 什么是 react 组件插槽

    - 就是将父组件标签的内容显示到子组件上

    - 在 Vue 中， slot></slot ，在 React 里，父组件写法是相同的，但子组件是采用 `{this.props.children}` 来实现。

      ```js
       render() {//父
          return (
             <Child>
               <h1>插槽（组合）内容</h1>
             </Child>
          );
        }
      export class Child extends Component {//子
        render() {
          return (
            <div>
             {this.props.children}
            </div>
          );
        }
      }
      ```

17. setState 相关

    - setState 在事件体系（render， onClick ）及其生命周期里是异步的，除此之外是同步的，如定时器

    - setState 的调用会引起 React 的更新生命周期的 4 个函数执行。

      shouldComponentUpdate
      componentWillUpdate
      render
      componentDidUpdate

    - 更改引用内型时需要先展开在赋值，这样才会让 PureComponent 的浅比较能识别才能实时更行到页面上

18. shouldComponentUpdate 有什么作用

    - nexrProps/nexrState 表示下一次 props 和下一次 state 的值
    - 返回 false 时候，render()方法不执行，组件也就不会渲染，返回 true 时，组件照常重渲染

    ```js
    shouldComponentUpdate(nexrProps) {
    	if (this.props.num === nexrProps.num) {
    		return false
    	}
    	return true;
    }
    复制代码
    ```

19. PureComponent

    - PureComponent 自带通过 props 和 state 的浅对比来实现 shouldComponentUpate()，而 Component 没有。
    - 与 `shouldComponentUpdate` 共存,如果 `PureComponent` 里有 `shouldComponentUpdate` 函数的话，直接使用 `shouldComponentUpdate` 的结果作为是否更新的依据
    - 没有 `shouldComponentUpdate` 函数的话, 则会判断该组件是否是 PureComponent，如果是的话，会对新旧 props、state 进行 shallowEqual 浅比较，一旦新旧不一致，会触发 update。

20.
