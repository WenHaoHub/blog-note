## css

#### 隐藏

1. opcity：0 占据空间 绑定事件也能触发
2. visibility：hidden 占据空间 绑定事件不触发
3. display：none

#### 定位

1. 绝对定位参照父级最近的相对定位，没有贼参照 html
2. **`sticky`** 粘性定位

#### 清除浮动

content:''',display:block,clear:both

# js

## string

#### 截取

1. substr(开始下标，截取个数) 不修改原来字符串 -1 时返回最后一位
2. substring（开始下标，结束下标 不包含）不修改原来数组 -1 是返回全部
3. slice(开始下标，结束下标 不包含) 不修改原来字符串 -1 返回最后一位

## 数组

#### 数组空洞

```js
let arr=[0,1]
arr[5]=5
//es5
arr==[0,1,empty x 3,5]
//es6
arr=[0,1,undefined，undefined，undefined5]
```

1. pop()删除数组最后一位，返回被删除的值
2. shift()删除数组第一位，返回被删除的值
3. unshift()在数组第一位添加，改变原来数组，返回数组长度
4. push()改变原来数组，返回数组长度
5. splice(从哪一位开始，删除多少位 可不填，插入数据...) ，返回被删除的数组数据
6. concat(),连接数组不会改变原来数组 let newArr=arr.concat( [],[] )
7. slice(开始位，结束位 可不填) 片段切出新数组
8. split()将字符串转化为数组
9. reduce(( 先前返回的值 , 当前元素的值，下标 ，数组 ),传递给函数的初始值) 没有第二个值 先前元素下标为 0 当前元素下标为 1
10. sort() 数子>A~Z>a~z>汉字 直接调用 sort 对数字排序是对比个十百位 如 [21,2,35,202,8]>>>[2, 202, 21, 35, 8] 需要借助传入参数 sort((index1,index0)=>index1-index0) 返回值大于 0 从小到大排列 小于 0 重大到小排列
11. includes(xxx) 查询数组是否存在该值 返回 boolean
12. indexOf(xxx) 查询该值在数组中的下标 无返回-1

## 对象

#### 判断对象

1. **typeof** xxx 此方法判断的数组、unll 都是 object
2. **Object.prototype.toString.call(**xxx) 能全部判断出准确结果 [object Function]，后面就是类型
3. `object instanceof constructor`：可以准确判断复杂引用的数据类型，但不能正确判断基础数据类型。后面跟的是一个构造函数（大写）

#### 循环

1. for in 适用于纯对象的遍历，并且只能输出**可枚举**属性 ，遍历数组输出的是下标
2. forEach 适用于需要知道索引值的数组遍历，不可 break
3. for of 适用于无需知道索引值的数组遍历，因为可以中断。另外对于其他字符串，类数组，类型数组的迭代，`for of`也更适用

#### hasOwnProperty

```js
const obj = {}
obj.property1 = 88

console.log(obj.hasOwnProperty('property1')) // true

console.log(obj.hasOwnProperty('toString')) // false

console.log(obj.hasOwnProperty('hasOwnProperty')) // false
```

用来判断一个属性是定义在对象本身而不是继承自[原型链](https://so.csdn.net/so/search?q=原型链&spm=1001.2101.3001.7020)的

## 原型、原型链

1.  每一个[javascript](https://so.csdn.net/so/search?q=javascript&spm=1001.2101.3001.7020)对象(除 null 外)创建的时候，都会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性
2.  每个[函数](https://so.csdn.net/so/search?q=函数&spm=1001.2101.3001.7020)都有一个 prototype 属性，这个属性指向函数的原型对象
3.  **--proto--**是实例指向原型的属性 prototype 是对象（函数也是对象）或者构造函数指向原型的属性
4.  每个原型都有一个 constructor 属性 constructor 属性，指向该关联的构造函数
5.  只能在函数上通过 prototype 添加原型属性，在对象上会报错 通过 new 关键字创建出来的能直接使用添加在原型上的属性跟方法
6.  原型链的尽头是 null，当查到 null 则抛出错误 no Fn 或者 undefined
7.  函数有原型 prototype 跟原型链*proto* ==>([[prototype]])，对象只有原型链
8.  class 类实例化的对象 类中的方法放在隐式原型上的
9.  class 的显示原型存放方法 calss.prototype new 出来的实例有个隐式原型**proto** 这两个相等

## this 指向

#### 三种指向

1.  指向 this 所在函数的直接调用者
2.  **事件**中指向当前的出发对象
3.  **new**的时候，指向 new 出来的对象

#### 定时器内

setTimeout()和 setInterval()函数体中的 this 指向 当前执行环境的 this

比如在 class 内里方法中定义的定时器 在调用方法执行时 this 指向当前类的 this

#### 箭头函数

1.  没有 this,箭头函数不会创建自己的 this,它只会从自己的作用域链的上一层继承 this。"，window 对象就是它的上一层 this，实际上对箭头函数来说，还是只有自己一级的作用域，和上一层的 window 作用域
2.  没有 argnments

#### class 类 this 指向

1. 类的 this 指向实例化对象
2. 类中的方法 this 指向其调用者 一般是实例化对象调用它所以还是指向实例化对象，当把它绑定在按钮上调用时 onclick=newObj.fn()时，this 就指向了按钮
3. 类里的方法默认开启严格模式 在 windows 调用时 this 就是 undefined 可以用箭头函数解决

#### 改变 this 指向

1. call（this,值 1，值 2...）
2. appyl(this,[值 1，值 2...])
3. bind(this,值 1，值 2...) 返回一个新的函数

## Promise

#### Promise.all()

```javascript
let p1 = new Promise((reslove) => {
  setTimeout(() => {
    reslove('get1')
  }, 1000)
})
var p = Promise.all([p1, p2, p3])
p.then((res) => {
  console.log('>>>res', res)
}).catch((err) => {
  console.log('>>>err', err)
})
```

1.  只有 123 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 123 的返回值组成一个数组，传递给 p 的回调函数。 顺序不变
2.  只要 123 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值（只有一个），会传递给 p 的回调函数。

#### Promise.race()

```
var p = Promise.race([p1,p2,p3]);
```

只要 1 2 3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的返回值。只返回最快的那一个，不管状态

#### Promise.any()

Promise.any(array) 只返回第一个成功的

#### promise.allSettled()

promise.allSettled(array)全部返回在 then 里 不管什么状态

## 克隆

1. json 克隆不能克隆函数、稀疏数组、正则对象、也会改变构造函数指向

## Event Loop

1. 宏任务 同步宏任务，异步宏任务（setTimeout setInterval、 setImmediate, I/O, UI rendering ）
2. 微任务 只有异步有微任务（Promise、，Object.observe(监听对象属性变化) 、MuTationObserve(监听 Dom 节点变化)）
3. 执行栈先执行同步宏任务 再取任务队列的执行
4. 同步宏任务----》异步放入对应任务队列—》异步微任务----》异步宏任务

## 闭包

1. 闭包是指一个函数，该函数能够使用另-一个函数里的局部变量，可以理解通过返回一个函数，能够继续使用局部变量
2. 创建私有环境 独立的词法作用域 能够实现类似私有变量的效果
3. 延长变量的生命周期 防止垃圾回收
4. 保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系）；
5. 保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；

#### 内存泄漏

1. console.log 传递给它的变量信息不能被回收
2. 意外的全局变量
3. 闭包 由于闭包会携带包含他的函数作用域，因此会比其他函数占用更多内存 把返回函数的接收变量值为 null
4. DOM 泄露
5. 未清除的定时器

#### 作用域

1. 全局作用域 script
2. 局部作用域 local

#### 垃圾回收

1. 全自动完成内存的分配和回收,在程序上无需做任何事情。但是需要留意变量的使用，避免 JavaScript 无法回收不使用的变量

2. 垃圾回收执行时，会阻碍 JavaScript 代码执行，当 JavaScript 在回收
   数据时，那么我们写的程序会被暂停

3. 方式

   - 标记清除（主流）

     - 打上**进入环境** 跟 **离开环境** 标签 没有被执行到的打上 **任意标签** 垃圾回收时清除除了 （进入环境 闭包标签 ）的标签

   - 引用计数

     定义了一个值标记为 1 引用了标记-1 为 0 为 0 的要被垃圾回收

4. 手动清楚 obj=null

## 防抖节流

1.  debounce 防抖函数 一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效

    ```js
    function debounce(fn, delay = 1000) {
      let timer = null
      return function () {
        clearTimeout(tiemr)
        timer = setTimeout(() => {
          fn.apply(this, arguments)
        }, delay)
      }
    }
    ```

2.  throttle 节流函数 一个函数执行一次后，只有大于设定的执行周期才会执行第二次

        ```js

    function thorttle(fn,delay=1000){

    //method 1 首次不会执行 需等待计时触发------------
    let switch=true
    return function(){
    if(!switch) return;
    switch=false
    setTimeout(()=>{
    fn.apply(this,arguments)
    switch=true
    },delay)
    }
    //method 1 over------------

    //method 2 首次会执行 最后一次停止动作后没有延时执行程序------------
    let last=0
    return function(){
    let now=+new Date()
    if(now-last>delay){
    fn.apply(this,arguments)
    last=now
    };

    }

    ```

    ```

# 网络

#### 浏览器输入 URL

1. 网络层面
   - 构建请求
   - 查找强缓存
   - DNS 解析
   - 建立 tcp 连接（三次握手）
2. 浏览器简析层
   - 解析 html 构建 dom 树
   - 解析 css 构建 css 树、样式计算
   - 生成布局树 Layer Tree
3. 浏览器渲染层
   - 建立图层树 layer Tree
   - 生成绘制列表
   - 生成图块并栅格化
   - 显示器显示内容
   - 最后断开连接 tcp 四次挥手

#### http 请求过程

1. 建立 tcp（三握）连接
2. 发送请求行
3. 发送请求头
4. 到达服务器 发送状态行
5. 服务器 发送响应头
6. 服务器 发送响应数据
7. 断开 tcp）（四挥）连接

#### get post 区别

1. get 请求会被浏览器主动缓存，请求参数会被浏览器完整的保存在历史记录中，而 post 不会默认缓存，且设置缓存了参数也不会被保留
2. get 请求传输参数是有长度限制的 2000~8000byt（浏览器限制），post 没有长度限制
3. get 参数通过 URL 传递，暴露在外不安全，post 参数放在 request body 报文内部更加安全
4. 对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务端响应 200，请求成功。
5. 对于 POST 方式的请求，浏览器会先发送 http header 给服务端（其发生的原因多样，‌ 包括但不限于跨域请求的安全机制、‌ 代码错误、‌ 网络问题以及服务器重定向等），告诉服务端等一下会有数据过来，服务端响应 100 continue，告诉浏览器我已经准备接收数据，浏览器再 post 发送一个 data 给服务端，服务端响应 200，请求成功

#### http 缓存

1. 强缓存 Expires（过期时间）/ Cache-Contro（优先级高）
2. 协商缓存 Last-Modified/Etag(优先级高) L 实用不经常改变的大文件，E 实用经常改变的小文件，协商缓存会向服务器发送一次请求
3. 在实际缓存机制中两者合作使用，浏览器首先会根据请求的信息来判断强缓存是否命中，命中直接使用未命中则使用协商缓存向服务器发送一次请求，命中则不返回资源浏览器直接使用本地资源的副本，不命中则返回最新的资源给浏览器

#### 状态码

1. 2XX 成功
   - 200 OK，表示从客户端发来的请求在服务器端被正确处理
   - 204 No content，表示请求成功，但响应报文不含实体的主体部分
2. 3XX 重定向
   - 301 永久性重定向，表示资源已被分配了新的 URL
   - 302 临时性重定向
   - 304 命中缓存
3. 4xx 客服端错误（请求报文/参数）有误
   - 400 请求报文存在语法错误
   - 401 无权访问， 需要有通过 HTTP 认证的认证信息
   - 403 表示对请求资源的访问被服务器拒绝
   - 404 表示在服务器上没有找到请求的资源
4. 5xx 服务器错误
   - 500 服务器执行请求时出错
   - 503 服务器过载或者正在停机维护 不能处理请求

## 学习计划

1. 按需引入

# Vue

#### data 为什么是函数

1.  一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造[函数](https://so.csdn.net/so/search?q=函数&spm=1001.2101.3001.7020)。如果 data 是对象的话，对象属于引用类型，会影响到所有的实例
2.  data 返回一个函数 ，components 注册时调用函数返回值创建对象值保存在堆中
3.  data 如果是个对象，注册组件时是引用了对象保存在栈中的地址，全部指向在堆中地址的值
4.  返回函数属于闭包技术，创建组件自己的私有变量，独立的词法作用域， 而函数恰好提供了一个独立作用域

#### 响应式原理

vue.js 是采用数据劫持结合发布者-订阅者模式的方式通过 Object.defineProperty()来劫持各个属性的 setter 和 getter，在数据变动时发布消息给订阅者，触发相应的监听回调

#### 数组去重

1. es6 自带 flat（Infinity 无限极）
2. 转化为字符串 在转化为数组 arr.toString().split(',') .map(item=>parseFloat(item))
3. JSON.steingify(arr)
4. 循环验证是否为数组

#### 跨域

jsonp（前端），cors（后端）跨域资源共享，只能共享一个，所以基于 http proxy 实现跨域请求

#### key

1. key 的作用主要是为了高效的更新虚拟 DOM,其原理是 vue 在 patch 过程中通过 key 可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素,使得整个 patch 过程更加高效,减少 DOM 操作量，提高性能。
2. 另外,若不设置 key 还可能在列表更新时引发一些隐蔽的 bug
3. vue 中在使用相同标签名元素的过渡切换时，也会使用到 key 属性,其期的也是为了让 vue 可以区分它们，否则 vue 只会替换其内部属性而不会触发过渡效果。

#### v-if 和 v-for

1. 显然 v-for 优先于 v-if 被解析（把你是怎么知道的告诉面试官，查看了源码)
2. l 如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能
3. 要避免出现这种情况，则在外层嵌套 template，在这一层进行 v-if 判断，然后在内部进行 v-for 循环

#### data 为函数

1. Vue 组件可能存在多个实例，如果使用对象形式定义 data，则会导致它们共用一个 data 对象，那么状态变更将会影响所有组件实例，这是不合理的;采用函数形式定义，在 initData 时会将其作为工厂函数返回全新 data 对象，有效规避多实例之间状态污染问题。而在 Vue 根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况。
2. 同一个组件被复用多次，会创建多个实例。这些实例用的是同一个构造函数，如果 data 是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过 data 函数返回一个对象作为组件的状态

#### VUE 组件化

1. 组件是独立和可复用的代码组织单元。组件系统是 Vue 核心特性之一，它使开发者使用小型、独立和通常可
   复用的组件构建大型应用;
2. 组件化开发能大幅提高应用开发效率、测试性、复用性等;
3. 组件使用按分类有:页面组件、业务组件、通用组件;
4. vue 的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于
   vueComponent，扩展于 Vue;
5. vue 中常见组件化技术有:属性 prop，自定义事件，插槽等，它们主要用于组件通信、扩展等;
6. 合理的划分组件，有助于提升应用性能;
7. 组件应该是高内聚、低耦合的;
8. 遵循单向数据流的原则。r

#### MVVM

数据更改视图更改，视图更改数据也更改

1. 2.0vue
   - 通过隆加上对原来对象数数据的 defineProperty 劫持，配合属性 getset 修改数据，set 设置克隆对象调用渲染方法
   - 元对象数据改变触发 defin
2. vue3.0
   - proxy+Reflect

#### 生命周期

#### 编码优化

1. 不要将所有的数据都放在 data 中，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher
2. vue 在 v-for 时给每项元素绑定事件需要用事件代理
3. SPA 页面采用 keep-alive 缓存组件
4. 拆分组件(提高复用性、增加代码的可维护性,减少不必要的渲染）
5. v-if 当值为 false 时内部指令不会执行,具有阻断功能，很多情况下使用 v-if 替代 v-show
6. key 保证唯一性（默认 vue 会采用就地复用策略）
7. object.freeze 冻结数据
8. 合理使用路由懒加载、异步组件
9. 尽量采用 runtime 运行时版本
10. 数据持久化的问题（防抖、节流）
11. 不要将所有的数据都放在 data 中，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher

#### 路由传参

1. url 展示上:params 类似于 post，query 类似于 get，也就是安全问题
2. params 传值相对更安全点，query 通过 url 传参，刷新页面还在 params 刷新页面不在了

```js
this.$router.push({
    //query
          path: '/describe',
          query: {id: id }
    //pamres
    name:组件名字
    params:{id:111}
        })
```

#### 路由守卫

1. 全局前置守卫 roter.beforeEach afterEach
2. 路由独享守卫 beforeEnter
3. 组件内置守卫 router.beforeRouterEntet upDate leave

## 语法

#### 受控/非受控组件

1. 非受控 现用现取 值由外部输入决定（官方说明请勿过度使用 ref）
2. 受控组件就是不通过 ref 取值 通过 event.target.value 边改变边往 state 里放

#### 函数柯里化

通过函数调用返回函数的方式，实现多次接收参数最后统一处理的函数编码形式 场景 react onClick 事件方法传参

## 生命周期

初始化

1. constructor
2. co'm'po'nentwillMount 16.8 以后加 UNSAFE\_
3. render >>>执行子组件的 componentRecivePeops props 变化触发 16.8 以后加 UNSAFE\_
4. componentDidMpount

更新 setState

1. shouldComponentUpdate 不写默认返回 true 继续执行
2. componentWillUpdate 16.8 以后加 UNSAFE\_
3. render
4. componentDidUpdate

强制跟新 forceUpdate（）

1. componentWillUpdate render componentDidUpdate

卸载阶段

1. componentWillUnmount

# 算法

#### 对调变量

```js
let a=3 b=5
a=[b,b=a][0]
[a,b]=[b,a]
let a=[a,b]
b=a[1] a=a[0]
```

# webpack

## 运行流程

1. 读取 webpack 配置参数
2. 启动 webpack 创建 Compiler 对象并开始解析目录
3. 从入口文件 entry 开始解析，递归遍历分析形成依赖关系
4. 对不同文件类型模块使用对应 loader 进行编译，转换成 javascript 文件
5. 整个过程中 webpack 会通过发布订阅模式向外抛出一些 hooks，而 webpack 插件可以通过监听这些关键的时间节点，执行插件任务进而达到干预输出结果的目的

## loader

本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。

1. ​ [postcss-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Floaders%2Fpostcss-loader%2F) css 兼容性
2. `vue-loader`：加载 Vue.js 单文件组件
3. `sass-loader`：将 SCSS/SASS 代码转换成 CSS
4. `style-loader`：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS

## plugin

基于事件流框架 `Tapable`，插件可以扩展 Webpack 的功能，可以贯穿 Webpack 打包的生命周期，执行不同的任务（按需加载，代码压缩等一系列功能 ）

1. 清空打包目录
2. 清除无用 css
3. 代码懒加载
4. 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)

## 进阶优化

#### 优化 resolve

1. alias 配置别名
2. extensions 配置 引入模块后缀 import xxxfrom '../xx/xx/xx'; 优先查找项
3. modules 告诉 webpack 优先 src 目录下查找需要解析的文件，会大大节省查找时间 ·` modules: [resolve('src'), 'node_modules'],`
